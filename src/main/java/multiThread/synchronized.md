# Synchronized关键字 (原子性)

## Synchronized三种使用方式

* 修饰实例方法(给对象加锁): 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
* 修饰静态方法(给类加锁): 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
* 修饰代码块(给指定对象/类加锁): 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
    
    
    public synchronized void addA() {
            ...
        }
    public static synchronized void addA() {
            ...
        }
    synchronized (...) {
            ...
        }
    
## Synchronized底层原理

① synchronized 同步语句块的情况
        
    synchronized同步语句块的实现使用的是monitorenter和monitorexit指令
    其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。
    当执行monitorenter指令时，线程试图获取锁也就是获取 monitor的持有权。
    (monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的)
    当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行monitorexit指令后，将锁计数器设为0，表明锁被释放
    如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
     
② synchronized 修饰方法的的情况
        
    JVM通过ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

## Synchronized的优化

① 偏向锁

    为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
    偏向锁在无竞争的情况下会把整个同步都消除掉。
    偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步
    但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失
    需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
        

② 轻量级锁

    在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。
    另外，轻量级锁的加锁和解锁都用到了CAS操作。
    轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
    如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。
    但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！
    如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁
        
③ 自旋锁和自适应自旋

    轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
    一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失
    所以为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。
    自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。
    如果自旋超过了限定次数任然没有获得锁，就应该挂起线程，
    自适应的自旋锁带来的改进就是：自旋的次数不固定，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。
        
④ 锁消除(JVM逃逸分析里的同步省略)
       
    虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。
    
## Synchronized 和 ReentrantLock 的区别
① 两者都是可重入锁

两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

② synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。

③ ReentrantLock 比 synchronized 增加了一些高级功能

相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）

    公平锁：
        多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
        优点：所有线程都能按顺序得到执行
        缺点：吞吐量会下降，除了第一位线程外，其他线程都会阻塞
        
    非公平锁：
        多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
        优点：减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
        缺点：可能会导致线程一直获取不到锁，导致饿死
   
    
        