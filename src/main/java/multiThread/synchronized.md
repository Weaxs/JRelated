> # Synchronized关键字

> Synchronized三种使用方式

    修饰实例方法(给对象加锁): 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁
    修饰静态方法(给类加锁): 也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
    修饰代码块(给指定对象/类加锁): 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
    
    public synchronized void addA() {
            ...
        }
    public static synchronized void addA() {
            ...
        }
    synchronized (...) {
            ...
        }
    
> Synchronized底层原理

    ① synchronized 同步语句块的情况
        synchronized同步语句块的实现使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。
        当执行monitorenter指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的)的持有权。
        当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行monitorexit指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
     
    ② synchronized 修饰方法的的情况
        JVM通过ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。

> Synchronized的优化

    ① 偏向锁
        为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
        偏向锁在无竞争的情况下会把整个同步都消除掉。
        偏向锁会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步
        但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失
        需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。
        
    ② 轻量级锁
        在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。
        另外，轻量级锁的加锁和解锁都用到了CAS操作。
        轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。
        如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。
        但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！
        如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁
        
    ③ 自旋锁和自适应自旋
        轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
        一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的
        所以为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。
        自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁。
        如果自旋超过了限定次数任然没有获得锁，就应该挂起线程，
        自适应的自旋锁带来的改进就是：自旋的次数不固定，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。
        
    ④ 锁消除(JVM逃逸分析里的同步省略)
        虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。
   
    
        